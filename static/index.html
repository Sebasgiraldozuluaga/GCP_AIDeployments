<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>I-SERV BOT - Chatbot Interno</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Apache ECharts for Generative BI -->
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'iserv-green': '#009639',
                        'iserv-dark-green': '#00843D',
                        'iserv-black': '#1a1a1a',
                    }
                }
            }
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        
        * {
            font-family: 'Inter', sans-serif;
        }
        
        .chat-container {
            height: calc(100vh - 80px);
        }
        
        .messages-container {
            height: calc(100% - 80px);
            overflow-y: auto;
            scroll-behavior: smooth;
        }
        
        .messages-container::-webkit-scrollbar {
            width: 6px;
        }
        
        .messages-container::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        
        .messages-container::-webkit-scrollbar-thumb {
            background: #009639;
            border-radius: 3px;
        }

        /* Added typing indicator animation */
        .typing-indicator {
            display: none;
            align-items: center;
            gap: 0.5rem;
        }

        .typing-indicator.active {
            display: flex;
        }

        .typing-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #009639;
            animation: typing 1.4s infinite;
        }

        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
                opacity: 0.7;
            }
            30% {
                transform: translateY(-6px);
                opacity: 1;
            }
        }

        /* Generative BI Chart Styles */
        .chart-container {
            width: 100%;
            min-height: 320px;
            margin: 12px 0;
            border-radius: 12px;
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border: 1px solid #e2e8f0;
            overflow: hidden;
        }

        .chart-wrapper {
            width: 100%;
            height: 320px;
        }

        .data-table-container {
            width: 100%;
            margin: 12px 0;
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid #e2e8f0;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.875rem;
        }

        .data-table thead {
            background: linear-gradient(135deg, #009639 0%, #00843D 100%);
        }

        .data-table th {
            padding: 12px 16px;
            text-align: left;
            font-weight: 600;
            color: white;
            text-transform: uppercase;
            font-size: 0.75rem;
            letter-spacing: 0.05em;
        }

        .data-table td {
            padding: 10px 16px;
            border-bottom: 1px solid #e2e8f0;
            color: #374151;
        }

        .data-table tbody tr:hover {
            background-color: #f0fdf4;
        }

        .data-table tbody tr:nth-child(even) {
            background-color: #f9fafb;
        }

        .data-table tbody tr:nth-child(even):hover {
            background-color: #f0fdf4;
        }

        .viz-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            background: linear-gradient(135deg, #009639 0%, #00843D 100%);
            color: white;
            border-radius: 20px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 8px;
        }

        .viz-badge svg {
            width: 12px;
            height: 12px;
        }

        /* Markdown Content Styles */
        .markdown-content {
            line-height: 1.6;
        }

        .markdown-content strong {
            font-weight: 600;
            color: #1f2937;
        }

        .markdown-content em {
            font-style: italic;
            color: #4b5563;
        }

        .markdown-list {
            list-style: none;
            padding-left: 0;
            margin: 4px 0;
        }

        .markdown-list-item {
            padding: 1px 0;
            padding-left: 16px;
            position: relative;
            line-height: 1.4;
        }

        .markdown-list-item::before {
            content: "‚Ä¢";
            position: absolute;
            left: 0;
            color: #009639;
            font-weight: bold;
            font-size: 0.9em;
        }

        .text-line {
            display: block;
            margin-bottom: 4px;
        }

        .text-line:last-child {
            margin-bottom: 0;
        }

        /* Thinking Chain Styles */
        .thinking-chain {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border: 1px solid #bae6fd;
            border-radius: 12px;
            padding: 12px 16px;
            margin-bottom: 12px;
            font-size: 0.85rem;
        }

        .thinking-header {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            user-select: none;
            color: #0369a1;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .thinking-header:hover {
            color: #0284c7;
        }

        .thinking-header svg {
            width: 18px;
            height: 18px;
            transition: transform 0.2s;
        }

        .thinking-header.collapsed svg {
            transform: rotate(-90deg);
        }

        .thinking-steps {
            padding-left: 8px;
            border-left: 3px solid #7dd3fc;
        }

        .thinking-steps.hidden {
            display: none;
        }

        .thinking-step {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            padding: 6px 0;
            color: #475569;
            font-size: 0.8rem;
            line-height: 1.4;
        }

        .thinking-step:not(:last-child) {
            border-bottom: 1px dashed #cbd5e1;
        }

        .step-icon {
            flex-shrink: 0;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
        }

        .step-icon.query { background: #dbeafe; color: #1d4ed8; }
        .step-icon.schema { background: #fef3c7; color: #b45309; }
        .step-icon.sql { background: #d1fae5; color: #059669; }
        .step-icon.result { background: #ede9fe; color: #7c3aed; }
        .step-icon.analyze { background: #fce7f3; color: #db2777; }

        .step-content {
            flex: 1;
        }

        .step-label {
            font-weight: 600;
            color: #334155;
            margin-right: 4px;
        }

        .step-sql {
            background: #1e293b;
            color: #e2e8f0;
            padding: 8px 12px;
            border-radius: 6px;
            font-family: 'Fira Code', 'Monaco', monospace;
            font-size: 0.75rem;
            margin-top: 4px;
            overflow-x: auto;
            white-space: pre-wrap;
            word-break: break-all;
        }

        /* Download Section Styles */
        .download-section {
            animation: fadeIn 0.3s ease-in-out;
        }

        .download-section button {
            transition: all 0.2s ease;
        }

        .download-section button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .markdown-content ul {
            margin: 8px 0;
            padding-left: 20px;
        }
    </style>
</head>
<body class="bg-gray-50">
    <!-- Header -->
    <header class="bg-white border-b border-gray-200 shadow-sm">
        <div class="max-w-7xl mx-auto px-6 py-4 flex items-center justify-between">
            <div class="flex items-center gap-4">
                <img src="/static/images/LOGO-I-SERV.png" alt="Logo de I‚ÄëSERV" class="h-12 w-auto" width="48" height="48" loading="lazy">
                <div>
                    <h1 class="text-xl font-bold text-iserv-black">I-SERV BOT</h1>
                    <p class="text-sm text-gray-500">Asistente Virtual Interno</p>
                </div>
            </div>
            <!-- Updated status indicator to be dynamic -->
            <div class="flex items-center gap-2">
                <div id="statusIndicator" class="w-2 h-2 bg-gray-400 rounded-full"></div>
                <span id="statusText" class="text-sm text-gray-600 font-medium">Conectando...</span>
            </div>
        </div>
    </header>

    <!-- Chat Container -->
    <main class="max-w-5xl mx-auto px-6 py-6">
        <div class="bg-white rounded-2xl shadow-lg chat-container">
            <!-- Messages Area -->
            <div class="messages-container p-6 space-y-4" id="messagesContainer">
                <!-- Removed example messages, they will be added dynamically -->
            </div>

            <!-- Input Area -->
            <div class="border-t border-gray-200 p-4">
                <form id="chatForm" class="flex items-end gap-3">
                    <textarea 
                        id="messageInput"
                        rows="1"
                        placeholder="Escribe tu mensaje aqu√≠..."
                        class="flex-1 resize-none border border-gray-300 rounded-xl px-4 py-3 focus:outline-none focus:ring-2 focus:ring-iserv-green focus:border-transparent"
                        style="max-height: 120px;"
                    ></textarea>
                    <button 
                        type="submit"
                        id="sendButton"
                        class="bg-iserv-green text-white px-6 py-3 rounded-xl font-semibold hover:bg-iserv-dark-green transition-colors flex items-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                        <span>Enviar</span>
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"/>
                        </svg>
                    </button>
                </form>
            </div>
        </div>
    </main>

    <script>
        // Configuration - Read API_BASE_URL from meta tag or use current origin as fallback
        const apiBaseUrlMeta = document.querySelector('meta[name="api-base-url"]');
        const API_BASE_URL = apiBaseUrlMeta 
            ? apiBaseUrlMeta.getAttribute('content') 
            : (window.API_BASE_URL || window.location.origin);
        const APP_NAME = 'app';
        const USER_ID = 'web-user';

        // State
        let sessionId = null;
        let isProcessing = false;
        let chartCounter = 0; // For unique chart IDs

        // ============================================
        // GENERATIVE BI - Visualization Functions
        // ============================================

        /**
         * Parse response to extract Generative BI JSON block
         */
        function parseGenerativeBIResponse(text) {
            // Use unique delimiters that won't appear in JSON content
            const biRegex = /<<<GENERATIVE_BI_START>>>\n([\s\S]*?)\n<<<GENERATIVE_BI_END>>>/;
            const match = text.match(biRegex);
            
            if (match) {
                let jsonStr = match[1];
                console.log('[BI] Found generative-bi block, length:', jsonStr.length);
                
                try {
                    const biData = JSON.parse(jsonStr);
                    console.log('[BI] JSON parsed successfully');
                    console.log('[BI] Visualization:', biData.visualization?.type, '- visualizable:', biData.visualization?.visualizable);
                    
                    const textWithoutBI = text.replace(biRegex, '').trim();
                    return {
                        hasVisualization: biData.visualization && biData.visualization.visualizable,
                        biData: biData,
                        cleanText: textWithoutBI || biData.text
                    };
                } catch (e) {
                    // Extract position from error message
                    const posMatch = e.message.match(/position (\d+)/);
                    const errorPos = posMatch ? parseInt(posMatch[1]) : 0;
                    
                    console.error('[BI] Error parsing JSON:', e.message);
                    console.error('[BI] JSON length:', jsonStr.length);
                    console.error('[BI] Character at error position:', JSON.stringify(jsonStr.charAt(errorPos)));
                    console.error('[BI] Char code at error:', jsonStr.charCodeAt(errorPos));
                    console.error('[BI] Context around error (pos-50 to pos+50):', JSON.stringify(jsonStr.substring(errorPos - 50, errorPos + 50)));
                    console.error('[BI] Last 100 chars of JSON:', JSON.stringify(jsonStr.substring(jsonStr.length - 100)));
                    
                    // Try to fix truncated JSON
                    try {
                        jsonStr = jsonStr.trim();
                        
                        // Check if JSON appears truncated (doesn't end with })
                        if (!jsonStr.endsWith('}')) {
                            console.log('[BI] JSON appears truncated, attempting to fix...');
                            // Find the last complete object/array
                            let lastBrace = jsonStr.lastIndexOf('}');
                            let lastBracket = jsonStr.lastIndexOf(']');
                            
                            // Try to close the JSON properly
                            // Count open braces/brackets
                            let braces = 0, brackets = 0;
                            for (let c of jsonStr) {
                                if (c === '{') braces++;
                                else if (c === '}') braces--;
                                else if (c === '[') brackets++;
                                else if (c === ']') brackets--;
                            }
                            
                            console.log('[BI] Unclosed braces:', braces, 'brackets:', brackets);
                            
                            // Add closing brackets/braces
                            let suffix = ']'.repeat(brackets) + '}'.repeat(braces);
                            if (suffix) {
                                // Truncate to last complete row if in array
                                let truncated = jsonStr.substring(0, jsonStr.lastIndexOf('],') + 1);
                                if (truncated.length > jsonStr.length * 0.8) {
                                    jsonStr = truncated + ']}}}';  // Close rows, data, visualization, root
                                    console.log('[BI] Truncated and closed JSON');
                                }
                            }
                        }
                        
                        const biData = JSON.parse(jsonStr);
                        console.log('[BI] JSON parsed after fix');
                        const textWithoutBI = text.replace(biRegex, '').trim();
                        return {
                            hasVisualization: biData.visualization && biData.visualization.visualizable,
                            biData: biData,
                            cleanText: textWithoutBI || biData.text
                        };
                    } catch (e2) {
                        console.error('[BI] Fix attempt failed:', e2.message);
                        // Return the text without the malformed block
                        const textWithoutBI = text.replace(biRegex, '').trim();
                        return { hasVisualization: false, cleanText: textWithoutBI || text };
                    }
                }
            }
            
            return { hasVisualization: false, cleanText: text };
        }

        /**
         * Format axis label for better readability
         */
        function formatAxisLabel(label, fieldName) {
            if (!label) return fieldName || '';
            
            // If it's a monetary field, add currency indicator
            if (isMonetaryField(fieldName) || isMonetaryField(label)) {
                // Check if already has currency indicator
                if (!label.toUpperCase().includes('COP') && !label.includes('$')) {
                    return `${label} (COP)`;
                }
            }
            
            // Capitalize first letter and improve readability
            return label.charAt(0).toUpperCase() + label.slice(1).toLowerCase();
        }

        /**
         * Create chart configuration for ECharts based on visualization type
         */
        function createChartConfig(vizConfig) {
            const { type, title, xAxis, yAxis, xAxisLabel, yAxisLabel, series, data, groupBy, legend } = vizConfig;
            
            if (!data || !data.columns || !data.rows) {
                return null;
            }

            const xIndex = data.columns.indexOf(xAxis);
            const yIndex = data.columns.indexOf(yAxis) !== -1 ? data.columns.indexOf(yAxis) : 
                           (series && series[0] ? data.columns.indexOf(series[0].field) : 1);
            const groupIndex = groupBy ? data.columns.indexOf(groupBy) : -1;

            // Theme colors
            const colors = ['#009639', '#00843D', '#4ade80', '#166534', '#15803d', '#22c55e', '#86efac', 
                          '#10b981', '#059669', '#34d399', '#6ee7b7', '#a7f3d0', '#d1fae5'];
            
            // Helper function to group data by a dimension
            function groupDataByDimension(rows, xIndex, groupIndex, yIndex) {
                const grouped = {};
                const xValues = new Set();
                
                rows.forEach(row => {
                    const xValue = row[xIndex];
                    const groupValue = row[groupIndex];
                    const yValue = row[yIndex];
                    
                    xValues.add(xValue);
                    
                    if (!grouped[groupValue]) {
                        grouped[groupValue] = {};
                    }
                    grouped[groupValue][xValue] = yValue;
                });
                
                return { grouped, xValues: Array.from(xValues).sort() };
            }

            switch (type) {
                case 'bar':
                    // Auto-detect grouped bars if groupBy is present
                    if (groupIndex !== -1 && data.columns.length >= 3) {
                        return createChartConfig({ ...vizConfig, type: 'groupedBar' });
                    }
                    return {
                        title: { text: title, left: 'center', textStyle: { fontSize: 14, fontWeight: 600, color: '#1f2937' } },
                        tooltip: { 
                            trigger: 'axis', 
                            axisPointer: { type: 'shadow' },
                            formatter: function(params) {
                                if (!params || params.length === 0) return '';
                                const param = params[0];
                                const value = param.value;
                                const seriesName = param.seriesName || yAxis;
                                const formattedValue = isMonetaryField(yAxis) 
                                    ? formatCurrency(value) 
                                    : formatNumber(value, yAxis);
                                return `${param.axisValue}<br/>${seriesName}: ${formattedValue}`;
                            }
                        },
                        grid: { left: '3%', right: '4%', bottom: '10%', top: '15%', containLabel: true },
                        xAxis: {
                            type: 'category',
                            data: data.rows.map(row => row[xIndex]),
                            axisLabel: { rotate: data.rows.length > 6 ? 30 : 0, fontSize: 11 },
                            name: formatAxisLabel(xAxisLabel, xAxis) || formatAxisLabel(xAxis, xAxis),
                            nameLocation: 'middle',
                            nameGap: 35,
                            nameTextStyle: { fontSize: 12, fontWeight: 500 }
                        },
                        yAxis: {
                            type: 'value',
                            name: formatAxisLabel(yAxisLabel, yAxis) || formatAxisLabel(yAxis, yAxis),
                            nameLocation: 'middle',
                            nameGap: 50,
                            nameTextStyle: { fontSize: 12, fontWeight: 500 },
                            axisLabel: { formatter: (val) => formatNumber(val, yAxis) }
                        },
                        series: [{
                            name: series && series[0] ? series[0].name : yAxis,
                            type: 'bar',
                            data: data.rows.map(row => row[yIndex]),
                            itemStyle: { 
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: '#009639' },
                                    { offset: 1, color: '#00843D' }
                                ]),
                                borderRadius: [4, 4, 0, 0]
                            },
                            emphasis: { itemStyle: { color: '#4ade80' } }
                        }]
                    };

                case 'line':
                    return {
                        title: { text: title, left: 'center', textStyle: { fontSize: 14, fontWeight: 600, color: '#1f2937' } },
                        tooltip: { 
                            trigger: 'axis',
                            formatter: function(params) {
                                if (!params || params.length === 0) return '';
                                const param = params[0];
                                const value = param.value;
                                const seriesName = param.seriesName || yAxis;
                                const formattedValue = isMonetaryField(yAxis) 
                                    ? formatCurrency(value) 
                                    : formatNumber(value, yAxis);
                                return `${param.axisValue}<br/>${seriesName}: ${formattedValue}`;
                            }
                        },
                        grid: { left: '3%', right: '4%', bottom: '10%', top: '15%', containLabel: true },
                        xAxis: {
                            type: 'category',
                            data: data.rows.map(row => row[xIndex]),
                            axisLabel: { rotate: data.rows.length > 8 ? 30 : 0, fontSize: 11 },
                            name: xAxisLabel || xAxis,
                            nameLocation: 'middle',
                            nameGap: 35
                        },
                        yAxis: {
                            type: 'value',
                            name: yAxisLabel || yAxis,
                            nameLocation: 'middle',
                            nameGap: 50,
                            axisLabel: { formatter: (val) => formatNumber(val, yAxis) }
                        },
                        series: [{
                            name: series && series[0] ? series[0].name : yAxis,
                            type: 'line',
                            data: data.rows.map(row => row[yIndex]),
                            smooth: true,
                            lineStyle: { color: '#009639', width: 3 },
                            itemStyle: { color: '#009639' },
                            areaStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: 'rgba(0, 150, 57, 0.3)' },
                                    { offset: 1, color: 'rgba(0, 150, 57, 0.05)' }
                                ])
                            }
                        }]
                    };

                case 'pie':
                    return {
                        title: { text: title, left: 'center', textStyle: { fontSize: 14, fontWeight: 600, color: '#1f2937' } },
                        tooltip: { 
                            trigger: 'item', 
                            formatter: function(params) {
                                const value = params.value;
                                const formattedValue = isMonetaryField(yAxis) 
                                    ? formatCurrency(value) 
                                    : formatNumber(value, yAxis);
                                return `${params.name}: ${formattedValue} (${params.percent}%)`;
                            }
                        },
                        legend: { orient: 'horizontal', bottom: '5%', left: 'center' },
                        series: [{
                            type: 'pie',
                            radius: ['40%', '70%'],
                            center: ['50%', '45%'],
                            avoidLabelOverlap: true,
                            itemStyle: { borderRadius: 8, borderColor: '#fff', borderWidth: 2 },
                            label: { show: true, formatter: '{b}: {d}%' },
                            emphasis: {
                                label: { show: true, fontSize: 14, fontWeight: 'bold' },
                                itemStyle: { shadowBlur: 10, shadowOffsetX: 0, shadowColor: 'rgba(0, 0, 0, 0.5)' }
                            },
                            data: data.rows.map((row, i) => ({
                                name: row[xIndex],
                                value: row[yIndex],
                                itemStyle: { color: colors[i % colors.length] }
                            }))
                        }]
                    };

                case 'area':
                    return {
                        title: { text: title, left: 'center', textStyle: { fontSize: 14, fontWeight: 600, color: '#1f2937' } },
                        tooltip: { 
                            trigger: 'axis', 
                            axisPointer: { type: 'cross' },
                            formatter: function(params) {
                                if (!params || params.length === 0) return '';
                                const param = params[0];
                                const value = param.value;
                                const seriesName = param.seriesName || yAxis;
                                const formattedValue = isMonetaryField(yAxis) 
                                    ? formatCurrency(value) 
                                    : formatNumber(value, yAxis);
                                return `${param.axisValue}<br/>${seriesName}: ${formattedValue}`;
                            }
                        },
                        grid: { left: '3%', right: '4%', bottom: '10%', top: '15%', containLabel: true },
                        xAxis: {
                            type: 'category',
                            boundaryGap: false,
                            data: data.rows.map(row => row[xIndex]),
                            axisLabel: { rotate: data.rows.length > 8 ? 30 : 0, fontSize: 11 },
                            name: xAxisLabel || xAxis,
                            nameLocation: 'middle',
                            nameGap: 35
                        },
                        yAxis: {
                            type: 'value',
                            name: yAxisLabel || yAxis,
                            nameLocation: 'middle',
                            nameGap: 50,
                            axisLabel: { formatter: (val) => formatNumber(val, yAxis) }
                        },
                        series: [{
                            name: series && series[0] ? series[0].name : yAxis,
                            type: 'line',
                            stack: 'Total',
                            areaStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: 'rgba(0, 150, 57, 0.5)' },
                                    { offset: 1, color: 'rgba(0, 150, 57, 0.1)' }
                                ])
                            },
                            emphasis: { focus: 'series' },
                            lineStyle: { color: '#009639', width: 2 },
                            itemStyle: { color: '#009639' },
                            data: data.rows.map(row => row[yIndex])
                        }]
                    };

                case 'groupedBar':
                case 'stackedBar':
                    if (groupIndex === -1) {
                        // Fallback to regular bar if no groupBy
                        return createChartConfig({ ...vizConfig, type: 'bar' });
                    }
                    
                    const { grouped, xValues } = groupDataByDimension(data.rows, xIndex, groupIndex, yIndex);
                    const groupValues = Object.keys(grouped).sort();
                    
                    return {
                        title: { text: title, left: 'center', textStyle: { fontSize: 14, fontWeight: 600, color: '#1f2937' } },
                        tooltip: { 
                            trigger: 'axis', 
                            axisPointer: { type: 'shadow' },
                            formatter: function(params) {
                                if (!params || params.length === 0) return '';
                                let result = `${params[0].axisValue}<br/>`;
                                params.forEach(param => {
                                    const formattedValue = isMonetaryField(yAxis) 
                                        ? formatCurrency(param.value) 
                                        : formatNumber(param.value, yAxis);
                                    result += `${param.marker} ${param.seriesName}: ${formattedValue}<br/>`;
                                });
                                return result;
                            }
                        },
                        legend: {
                            show: legend && legend.show !== false,
                            data: legend && legend.data ? legend.data : groupValues,
                            orient: 'horizontal',
                            bottom: '0%',
                            left: 'center',
                            textStyle: { fontSize: 11 }
                        },
                        grid: { left: '3%', right: '4%', bottom: legend && legend.show !== false ? '15%' : '10%', top: '15%', containLabel: true },
                        xAxis: {
                            type: 'category',
                            data: xValues,
                            axisLabel: { rotate: xValues.length > 8 ? 45 : 0, fontSize: 11 },
                            name: formatAxisLabel(xAxisLabel, xAxis) || formatAxisLabel(xAxis, xAxis),
                            nameLocation: 'middle',
                            nameGap: 35,
                            nameTextStyle: { fontSize: 12, fontWeight: 500 }
                        },
                        yAxis: {
                            type: 'value',
                            name: formatAxisLabel(yAxisLabel, yAxis) || formatAxisLabel(yAxis, yAxis),
                            nameLocation: 'middle',
                            nameGap: 50,
                            nameTextStyle: { fontSize: 12, fontWeight: 500 },
                            axisLabel: { formatter: (val) => formatNumber(val, yAxis) }
                        },
                        series: groupValues.map((groupValue, idx) => ({
                            name: groupValue,
                            type: 'bar',
                            stack: type === 'stackedBar' ? 'Total' : undefined,
                            data: xValues.map(xValue => grouped[groupValue][xValue] || 0),
                            itemStyle: { 
                                color: colors[idx % colors.length],
                                borderRadius: type === 'stackedBar' ? [0, 0, 0, 0] : [4, 4, 0, 0]
                            },
                            emphasis: { itemStyle: { color: colors[(idx + 1) % colors.length] } }
                        }))
                    };

                case 'multiLine':
                    if (groupIndex === -1) {
                        // Fallback to regular line if no groupBy
                        return createChartConfig({ ...vizConfig, type: 'line' });
                    }
                    
                    const lineGrouped = groupDataByDimension(data.rows, xIndex, groupIndex, yIndex);
                    const lineGroupValues = Object.keys(lineGrouped.grouped).sort();
                    
                    return {
                        title: { text: title, left: 'center', textStyle: { fontSize: 14, fontWeight: 600, color: '#1f2937' } },
                        tooltip: { 
                            trigger: 'axis',
                            formatter: function(params) {
                                if (!params || params.length === 0) return '';
                                let result = `${params[0].axisValue}<br/>`;
                                params.forEach(param => {
                                    const formattedValue = isMonetaryField(yAxis) 
                                        ? formatCurrency(param.value) 
                                        : formatNumber(param.value, yAxis);
                                    result += `${param.marker} ${param.seriesName}: ${formattedValue}<br/>`;
                                });
                                return result;
                            }
                        },
                        legend: {
                            show: legend && legend.show !== false,
                            data: legend && legend.data ? legend.data : lineGroupValues,
                            orient: 'horizontal',
                            bottom: '0%',
                            left: 'center',
                            textStyle: { fontSize: 11 }
                        },
                        grid: { left: '3%', right: '4%', bottom: legend && legend.show !== false ? '15%' : '10%', top: '15%', containLabel: true },
                        xAxis: {
                            type: 'category',
                            data: lineGrouped.xValues,
                            axisLabel: { rotate: lineGrouped.xValues.length > 8 ? 30 : 0, fontSize: 11 },
                            name: formatAxisLabel(xAxisLabel, xAxis) || formatAxisLabel(xAxis, xAxis),
                            nameLocation: 'middle',
                            nameGap: 35
                        },
                        yAxis: {
                            type: 'value',
                            name: formatAxisLabel(yAxisLabel, yAxis) || formatAxisLabel(yAxis, yAxis),
                            nameLocation: 'middle',
                            nameGap: 50,
                            axisLabel: { formatter: (val) => formatNumber(val, yAxis) }
                        },
                        series: lineGroupValues.map((groupValue, idx) => ({
                            name: groupValue,
                            type: 'line',
                            smooth: true,
                            data: lineGrouped.xValues.map(xValue => lineGrouped.grouped[groupValue][xValue] || 0),
                            lineStyle: { color: colors[idx % colors.length], width: 3 },
                            itemStyle: { color: colors[idx % colors.length] },
                            emphasis: { focus: 'series' }
                        }))
                    };

                default:
                    return null;
            }
        }

        /**
         * Check if a field name suggests it's a monetary value
         */
        function isMonetaryField(fieldName) {
            if (!fieldName) return false;
            const fieldLower = String(fieldName).toLowerCase();
            const monetaryKeywords = ['total', 'precio', 'costo', 'valor', 'monto', 'factura', 'compra', 'venta', 'subtotal', 'iva', 'retefuente'];
            return monetaryKeywords.some(keyword => fieldLower.includes(keyword));
        }

        /**
         * Render thinking chain (chain of thought)
         */
        function renderThinkingChain(thinkingSteps) {
            if (!thinkingSteps || thinkingSteps.length === 0) return '';
            
            const thinkingId = `thinking-${Date.now()}`;
            
            let stepsHtml = thinkingSteps.map((step, index) => {
                let iconClass = 'query';
                let icon = 'üîç';
                
                if (step.type === 'schema') {
                    iconClass = 'schema';
                    icon = 'üìã';
                } else if (step.type === 'sql') {
                    iconClass = 'sql';
                    icon = 'üíæ';
                } else if (step.type === 'result') {
                    iconClass = 'result';
                    icon = 'üìä';
                } else if (step.type === 'analyze') {
                    iconClass = 'analyze';
                    icon = 'üß†';
                }
                
                let contentHtml = `<span class="step-label">${step.label || step.type}:</span> ${escapeHtml(step.content || '')}`;
                
                // If there's SQL, show it in a code block
                if (step.sql) {
                    contentHtml += `<div class="step-sql">${escapeHtml(step.sql)}</div>`;
                }
                
                return `
                    <div class="thinking-step">
                        <div class="step-icon ${iconClass}">${icon}</div>
                        <div class="step-content">${contentHtml}</div>
                    </div>
                `;
            }).join('');
            
            return `
                <div class="thinking-chain">
                    <div class="thinking-header" onclick="toggleThinking('${thinkingId}')">
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/>
                        </svg>
                        <span>üß† Cadena de Pensamiento</span>
                    </div>
                    <div id="${thinkingId}" class="thinking-steps">
                        ${stepsHtml}
                    </div>
                </div>
            `;
        }

        /**
         * Toggle thinking chain visibility
         */
        window.toggleThinking = function(id) {
            const steps = document.getElementById(id);
            const header = steps.previousElementSibling;
            steps.classList.toggle('hidden');
            header.classList.toggle('collapsed');
        };

        /**
         * Format monetary values without decimals
         */
        function formatCurrency(value) {
            if (value === null || value === undefined) return '-';
            const num = typeof value === 'number' ? value : parseFloat(value);
            if (isNaN(num)) return String(value);
            // Round to nearest integer and format with thousand separators
            return Math.round(num).toLocaleString('es-CO');
        }

        /**
         * Format large numbers for display in charts
         */
        function formatNumber(num, fieldName = '') {
            if (num === null || num === undefined) return '-';
            const numValue = typeof num === 'number' ? num : parseFloat(num);
            if (isNaN(numValue)) return String(num);
            
            // If it's a monetary field, format as currency
            if (isMonetaryField(fieldName)) {
                if (numValue >= 1000000) {
                    return (Math.round(numValue / 1000000)) + 'M';
                }
                if (numValue >= 1000) {
                    return (Math.round(numValue / 1000)) + 'K';
                }
                return Math.round(numValue).toLocaleString('es-CO');
            }
            
            // For non-monetary numbers, keep original logic but without decimals
            if (numValue >= 1000000) return Math.round(numValue / 1000000) + 'M';
            if (numValue >= 1000) return Math.round(numValue / 1000) + 'K';
            return Math.round(numValue).toLocaleString('es-CO');
        }

        /**
         * Render data as an interactive table
         */
        function renderDataTable(data, title) {
            if (!data || !data.columns || !data.rows || data.rows.length === 0) {
                return '<p class="text-gray-500 italic">No hay datos para mostrar</p>';
            }

            let tableHtml = `
                <div class="data-table-container">
                    ${title ? `<div class="px-4 py-2 bg-gray-50 border-b border-gray-200 font-semibold text-gray-700">${title}</div>` : ''}
                    <div style="max-height: 300px; overflow-y: auto;">
                        <table class="data-table">
                            <thead>
                                <tr>
                                    ${data.columns.map(col => `<th>${col}</th>`).join('')}
                                </tr>
                            </thead>
                            <tbody>
                                ${data.rows.map(row => `
                                    <tr>
                                        ${row.map((cell, idx) => `<td>${formatCellValue(cell, data.columns[idx])}</td>`).join('')}
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
            return tableHtml;
        }

        /**
         * Format cell value for table display
         */
        function formatCellValue(value, columnName = '') {
            if (value === null || value === undefined) return '-';
            if (typeof value === 'number') {
                // Check if it's a monetary field
                if (isMonetaryField(columnName)) {
                    return formatCurrency(value);
                }
                // For other numbers, show without decimals if they're whole numbers
                if (Number.isInteger(value)) {
                    return value.toLocaleString('es-CO');
                }
                return value.toLocaleString('es-CO', { maximumFractionDigits: 2 });
            }
            return String(value);
        }

        /**
         * Get icon SVG for visualization badge
         */
        function getVizIcon(type) {
            const icons = {
                bar: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="12" width="4" height="9" rx="1"/><rect x="10" y="6" width="4" height="15" rx="1"/><rect x="17" y="3" width="4" height="18" rx="1"/></svg>',
                line: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="22,6 13.5,14.5 8.5,9.5 2,16"/><polyline points="16,6 22,6 22,12"/></svg>',
                pie: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21.21 15.89A10 10 0 1 1 8 2.83"/><path d="M22 12A10 10 0 0 0 12 2v10z"/></svg>',
                area: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 18v-6l5-4 4 4 5-6 4 4v8H3z"/></svg>',
                table: '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><line x1="3" y1="9" x2="21" y2="9"/><line x1="3" y1="15" x2="21" y2="15"/><line x1="9" y1="3" x2="9" y2="21"/><line x1="15" y1="3" x2="15" y2="21"/></svg>'
            };
            return icons[type] || icons.table;
        }

        /**
         * Generate CSV content from data
         */
        function generateCSV(data, title = 'datos') {
            if (!data || !data.columns || !data.rows) return null;
            
            const BOM = '\uFEFF'; // UTF-8 BOM for Excel compatibility
            let csv = BOM;
            
            // Header row
            csv += data.columns.map(col => `"${String(col).replace(/"/g, '""')}"`).join(',') + '\n';
            
            // Data rows
            data.rows.forEach(row => {
                csv += row.map(cell => {
                    if (cell === null || cell === undefined) return '""';
                    const cellStr = String(cell).replace(/"/g, '""');
                    // Check if cell contains comma, newline, or quote
                    if (cellStr.includes(',') || cellStr.includes('\n') || cellStr.includes('"')) {
                        return `"${cellStr}"`;
                    }
                    return cellStr;
                }).join(',') + '\n';
            });
            
            return csv;
        }

        /**
         * Download CSV file
         */
        function downloadCSV(data, filename = 'datos') {
            console.log('downloadCSV called with:', { data, filename });
            const csv = generateCSV(data, filename);
            if (!csv) {
                console.error('No data to download');
                alert('No hay datos para descargar');
                return;
            }
            
            try {
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.setAttribute('href', url);
                link.setAttribute('download', `${filename}_${new Date().toISOString().slice(0,10)}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                console.log('CSV download initiated');
            } catch (error) {
                console.error('Error downloading CSV:', error);
                alert('Error al descargar el archivo: ' + error.message);
            }
        }

        // Make downloadCSV available globally
        window.downloadCSV = downloadCSV;

        /**
         * Render download button for CSV
         */
        function renderDownloadButton(data, title, totalRecords) {
            if (!data || !data.columns || !data.rows || data.rows.length === 0) return '';
            
            const downloadId = `csvData_${++chartCounter}`;
            const filename = title ? title.replace(/[^a-zA-Z0-9√°√©√≠√≥√∫√±√Å√â√ç√ì√ö√ë\s]/g, '').replace(/\s+/g, '_').toLowerCase() : 'datos';
            
            // Store data for download in global scope
            window[downloadId] = { data, filename };
            
            return `
                <div class="download-section mt-3 p-3 bg-blue-50 rounded-lg border border-blue-200">
                    <div class="flex items-center justify-between">
                        <div class="flex items-center gap-2">
                            <svg class="w-5 h-5 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
                            </svg>
                            <span class="text-sm text-blue-800">
                                <strong>${totalRecords} registros</strong> disponibles para descargar
                            </span>
                        </div>
                        <button 
                            onclick="window.downloadCSV(window.${downloadId}.data, window.${downloadId}.filename)"
                            class="flex items-center gap-2 px-4 py-2 bg-blue-600 text-white text-sm font-medium rounded-lg hover:bg-blue-700 transition-colors cursor-pointer"
                        >
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/>
                            </svg>
                            Descargar CSV
                        </button>
                    </div>
                </div>
            `;
        }

        /**
         * Render visualization based on type
         */
        function renderVisualization(vizConfig) {
            console.log('[renderVisualization] Called with type:', vizConfig?.type, 'visualizable:', vizConfig?.visualizable);
            console.log('[renderVisualization] Data:', vizConfig?.data?.rows?.length, 'rows');
            
            const { type, title, data, fullData, isTop10, totalRecords, summary } = vizConfig;
            const chartId = `chart-${++chartCounter}`;

            // Determine which data to use for download (fullData if available, otherwise data)
            const downloadData = fullData && fullData.rows && fullData.rows.length > 0 ? fullData : data;
            const hasMoreData = totalRecords && totalRecords > 10;

            if (type === 'table' || type === 'none') {
                let html = renderDataTable(data, title);
                // Add download button if there's data
                if (hasMoreData && downloadData) {
                    html += renderDownloadButton(downloadData, title, totalRecords);
                }
                return html;
            }

            const chartConfig = createChartConfig(vizConfig);
            if (!chartConfig) {
                let html = renderDataTable(data, title);
                if (hasMoreData && downloadData) {
                    html += renderDownloadButton(downloadData, title, totalRecords);
                }
                return html;
            }

            // Top 10 indicator
            const top10Note = isTop10 && totalRecords > 10 
                ? `<div class="text-xs text-gray-500 mt-1 ml-1 italic">Mostrando Top 10 de ${totalRecords} registros totales</div>` 
                : '';

            // Download button if there are more records
            const downloadButton = hasMoreData && downloadData 
                ? renderDownloadButton(downloadData, title, totalRecords)
                : '';

            // Create chart container HTML
            const chartHtml = `
                <div class="viz-badge">
                    ${getVizIcon(type)}
                    <span>Generative BI - ${type.toUpperCase()}</span>
                </div>
                <div class="chart-container">
                    <div id="${chartId}" class="chart-wrapper"></div>
                </div>
                ${top10Note}
                ${downloadButton}
            `;

            // Schedule chart initialization after DOM insertion
            setTimeout(() => {
                const chartDom = document.getElementById(chartId);
                if (chartDom) {
                    const chart = echarts.init(chartDom);
                    chart.setOption(chartConfig);
                    
                    // Handle resize
                    window.addEventListener('resize', () => chart.resize());
                }
            }, 100);

            return chartHtml;
        }

        // DOM Elements
        const form = document.getElementById('chatForm');
        const messageInput = document.getElementById('messageInput');
        const messagesContainer = document.getElementById('messagesContainer');
        const sendButton = document.getElementById('sendButton');
        const statusIndicator = document.getElementById('statusIndicator');
        const statusText = document.getElementById('statusText');

        async function initializeSession() {
            try {
                updateStatus('Conectando...', false);

                console.log('[v0] Attempting to connect to:', `${API_BASE_URL}/apps/${APP_NAME}/users/${USER_ID}/sessions`);

                const response = await fetch(`${API_BASE_URL}/apps/${APP_NAME}/users/${USER_ID}/sessions`, {
                    method: 'POST',
                    mode: 'cors',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json',
                    },
                    body: JSON.stringify({})
                });

                console.log('[v0] Response status:', response.status);

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('[v0] Error response:', errorText);
                    throw new Error(`Failed to create session: ${response.status} ${response.statusText}`);
                }

                const data = await response.json();
                sessionId = data.id;

                updateStatus('En l√≠nea', true);
                console.log('[v0] Session initialized successfully:', sessionId);

                // Add welcome message
                addMessage('¬°Hola! Soy I-SERV BOT, tu asistente virtual para gesti√≥n interna. ¬øEn qu√© puedo ayudarte hoy?', 'bot');

            } catch (error) {
                console.error('[v0] Error initializing session:', error);
                updateStatus('Error de conexi√≥n', false);

                let errorMsg = 'No se pudo conectar al servidor. ';
                if (error.name === 'TypeError' && error.message.includes('fetch')) {
                    errorMsg += 'Por favor verifica que la API est√© en ejecuci√≥n. ';
                }
                errorMsg += `Error: ${error.message}`;

                addMessage(errorMsg, 'system');
            }
        }

        function updateStatus(message, isConnected) {
            statusText.textContent = message;
            statusIndicator.className = `w-2 h-2 rounded-full ${isConnected ? 'bg-iserv-green animate-pulse' : 'bg-red-500'}`;
        }

        // Loading messages to show while processing
        const loadingMessages = [
            "Analizando tu consulta...",
            "Consultando la base de datos...",
            "Procesando los datos...",
            "Generando visualizaci√≥n...",
            "Preparando la respuesta...",
            "Casi listo...",
            "Organizando la informaci√≥n...",
            "Calculando resultados..."
        ];

        let loadingMessageInterval = null;
        let currentMessageIndex = 0;

        function getRandomLoadingMessage() {
            return loadingMessages[Math.floor(Math.random() * loadingMessages.length)];
        }

        function setTyping(isTyping, customMessage = null) {
            const existingIndicator = document.getElementById('typingIndicator');
            
            if (isTyping && !existingIndicator) {
                const initialMessage = customMessage || getRandomLoadingMessage();
                currentMessageIndex = 0;
                
                const typingDiv = document.createElement('div');
                typingDiv.id = 'typingIndicator';
                typingDiv.className = 'flex items-start gap-3';
                typingDiv.innerHTML = `
                    <div class="w-10 h-10 bg-iserv-green rounded-full flex items-center justify-center flex-shrink-0">
                        <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"/>
                        </svg>
                    </div>
                    <div class="flex-1">
                        <div class="bg-gray-100 rounded-2xl rounded-tl-sm px-5 py-3 inline-block">
                            <div class="flex items-center gap-2">
                                <div class="typing-indicator active">
                                    <div class="typing-dot"></div>
                                    <div class="typing-dot"></div>
                                    <div class="typing-dot"></div>
                                </div>
                                <span class="text-sm text-gray-600 ml-2" id="loadingMessage">${initialMessage}</span>
                            </div>
                        </div>
                    </div>
                `;
                messagesContainer.appendChild(typingDiv);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;

                // Rotate messages every 2.5 seconds
                const messageElement = document.getElementById('loadingMessage');
                loadingMessageInterval = setInterval(() => {
                    const indicator = document.getElementById('typingIndicator');
                    if (messageElement && indicator) {
                        currentMessageIndex = (currentMessageIndex + 1) % loadingMessages.length;
                        messageElement.textContent = loadingMessages[currentMessageIndex];
                    } else {
                        clearInterval(loadingMessageInterval);
                        loadingMessageInterval = null;
                    }
                }, 2500);

            } else if (!isTyping && existingIndicator) {
                if (loadingMessageInterval) {
                    clearInterval(loadingMessageInterval);
                    loadingMessageInterval = null;
                }
                existingIndicator.remove();
            }
        }

        // Variable to track the current bot message element for streaming updates
        let currentBotMessageElement = null;
        let accumulatedText = '';

        /**
         * Add or update bot message with streaming text
         */
        function addOrUpdateBotMessage(text, isComplete = false) {
            // Don't create message if text is empty and not complete
            if (!text && !isComplete) return;
            
            const time = new Date().toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });
            
            if (!currentBotMessageElement) {
                // Create new message element only when we have text
                if (!text) return;
                
                const messageDiv = document.createElement('div');
                messageDiv.className = 'flex items-start gap-3';
                messageDiv.id = `bot-message-${Date.now()}`;
                
                messageDiv.innerHTML = `
                    <div class="w-10 h-10 bg-iserv-green rounded-full flex items-center justify-center flex-shrink-0">
                        <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"/>
                        </svg>
                    </div>
                    <div class="flex-1" style="max-width: calc(100% - 52px);">
                        <div class="thinking-chain-container"></div>
                        <div class="bg-gray-100 rounded-2xl rounded-tl-sm px-5 py-3 inline-block max-w-full">
                            <div class="text-gray-800 leading-relaxed whitespace-pre-wrap markdown-content bot-message-content"></div>
                        </div>
                        <div class="visualization-container"></div>
                        <p class="text-xs text-gray-400 mt-1 ml-1">${time}</p>
                    </div>
                `;
                
                messagesContainer.appendChild(messageDiv);
                currentBotMessageElement = messageDiv;
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }
            
            // Update text content
            const contentDiv = currentBotMessageElement.querySelector('.bot-message-content');
            if (contentDiv && text) {
                contentDiv.innerHTML = renderMarkdown(text);
            }
            
            // Check for generative-bi block when complete
            if (isComplete && text) {
                console.log('[v0] Processing complete text, length:', text.length);
                console.log('[v0] Text includes generative-bi:', text.includes('generative-bi'));
                
                const biResult = parseGenerativeBIResponse(text);
                console.log('[v0] biResult:', { hasVisualization: biResult.hasVisualization, hasBiData: !!biResult.biData });
                
                const vizContainer = currentBotMessageElement.querySelector('.visualization-container');
                const thinkingContainer = currentBotMessageElement.querySelector('.thinking-chain-container');
                
                if (biResult.hasVisualization || biResult.biData) {
                    console.log('[v0] Rendering visualization, type:', biResult.biData?.visualization?.type);
                    const viz = biResult.biData?.visualization;
                    const thinking = biResult.biData?.thinking;
                    
                    // Render thinking chain if available
                    if (thinking && thinking.length > 0 && thinkingContainer) {
                        thinkingContainer.innerHTML = renderThinkingChain(thinking);
                    }
                    
                    // Always show the original text from the agent (biData.text has the full response)
                    const originalText = biResult.biData?.text || biResult.cleanText;
                    if (contentDiv && originalText) {
                        contentDiv.innerHTML = renderMarkdown(originalText);
                    }
                    
                    // Render visualization
                    if (viz && vizContainer) {
                        vizContainer.innerHTML = renderVisualization(viz);
                    }
                } else if (contentDiv) {
                    contentDiv.innerHTML = renderMarkdown(biResult.cleanText);
                }
            }
            
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        async function sendMessage(message) {
            if (!message || isProcessing || !sessionId) {
                if (!sessionId) {
                    console.warn('[v0] Cannot send message: No session ID available');
                    addMessage('Por favor espera a que se establezca la conexi√≥n.', 'system');
                }
                return;
            }

            // Disable input
            isProcessing = true;
            sendButton.disabled = true;
            messageInput.disabled = true;

            // Add user message to chat
            addMessage(message, 'user');

            // Show typing indicator
            setTyping(true);

            // Reset streaming variables
            currentBotMessageElement = null;
            accumulatedText = '';

            try {
                console.log('[v0] Sending message to:', `${API_BASE_URL}/run`);

                const response = await fetch(`${API_BASE_URL}/run`, {
                    method: 'POST',
                    mode: 'cors',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json',
                    },
                    body: JSON.stringify({
                        appName: APP_NAME,
                        userId: USER_ID,
                        session_id: sessionId,
                        newMessage: {
                            role: 'user',
                            parts: [{ text: message }]
                        }
                    })
                });

                console.log('[v0] Response status:', response.status);

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('[v0] Error response:', errorText);
                    throw new Error(`Request failed: ${response.status} ${response.statusText}`);
                }

                // Hide typing indicator
                setTyping(false);

                const data = await response.json();
                console.log('[v0] Response received, data type:', typeof data);
                console.log('[v0] Response keys:', Object.keys(data || {}));
                
                let agentResponse = 'Disculpa, no pude procesar tu solicitud.';

                // Handle different response formats
                const events = Array.isArray(data) ? data : (data.events || []);
                console.log('[v0] Events count:', events.length);

                if (events.length > 0) {
                    // Look for the last event with text content
                    for (let i = events.length - 1; i >= 0; i--) {
                        const event = events[i];
                        console.log('[v0] Processing event', i, '- author:', event.author, '- has content:', !!event.content);
                        
                        if (event.content && event.content.parts) {
                            for (const part of event.content.parts) {
                                if (part.text) {
                                    agentResponse = part.text;
                    console.log('[v0] Found text response, length:', agentResponse.length);
                                        console.log('[v0] Response preview:', agentResponse.substring(0, 200));
                                        console.log('[v0] Has generative-bi:', agentResponse.includes('GENERATIVE_BI_START'));
                                    break;
                                }
                            }
                            if (agentResponse !== 'Disculpa, no pude procesar tu solicitud.') {
                                break;
                            }
                        }
                    }
                }

                // Add agent response to chat
                console.log('[v0] Adding message to chat, length:', agentResponse.length);
                addMessage(agentResponse, 'bot');

            } catch (error) {
                console.error('[v0] Request failed:', error);
                setTyping(false);

                let errorMsg = 'Error al comunicarse con el servidor. ';
                if (error.name === 'TypeError' && error.message.includes('fetch')) {
                    errorMsg += 'Verifica tu conexi√≥n a internet. ';
                }
                errorMsg += `Detalles: ${error.message}`;

                addMessage(errorMsg, 'system');
            } finally {
                // Re-enable input
                isProcessing = false;
                sendButton.disabled = false;
                messageInput.disabled = false;
                messageInput.focus();
                currentBotMessageElement = null;
            }
        }

        // Auto-resize textarea
        messageInput.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = Math.min(this.scrollHeight, 120) + 'px';
        });

        // Enter = enviar | Shift + Enter = nueva l√≠nea
        messageInput.addEventListener("keydown", function (e) {
            if (e.key === "Enter" && !e.shiftKey) {
                e.preventDefault();       // evita salto de l√≠nea
                form.requestSubmit();    // dispara el submit existente
            }
        });


        // Handle form submission
        form.addEventListener('submit', function(e) {
            e.preventDefault();
            const message = messageInput.value.trim();
            
            if (message) {
                sendMessage(message);
                messageInput.value = '';
                messageInput.style.height = 'auto';
            }
        });

        function addMessage(text, type) {
            const time = new Date().toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });
            
            const messageDiv = document.createElement('div');
            
            if (type === 'system') {
                // System message (centered, different style)
                messageDiv.className = 'flex justify-center';
                messageDiv.innerHTML = `
                    <div class="bg-yellow-50 border border-yellow-200 rounded-xl px-4 py-2 max-w-xl">
                        <p class="text-yellow-800 text-sm text-center">${text}</p>
                    </div>
                `;
            } else if (type === 'user') {
                messageDiv.className = 'flex items-start gap-3 justify-end';
                messageDiv.innerHTML = `
                    <div class="flex-1 flex flex-col items-end">
                        <div class="bg-iserv-green rounded-2xl rounded-tr-sm px-5 py-3 inline-block max-w-xl">
                            <p class="text-white leading-relaxed">${text}</p>
                        </div>
                        <p class="text-xs text-gray-400 mt-1 mr-1">${time}</p>
                    </div>
                    <div class="w-10 h-10 bg-iserv-black rounded-full flex items-center justify-center flex-shrink-0">
                        <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"/>
                        </svg>
                    </div>
                `;
            } else {
                // Bot message - Check for Generative BI visualization
                console.log('[addMessage] Bot message, length:', text.length);
                console.log('[addMessage] Has generative-bi:', text.includes('generative-bi'));
                
                const biResult = parseGenerativeBIResponse(text);
                console.log('[addMessage] biResult:', { hasVisualization: biResult.hasVisualization, hasBiData: !!biResult.biData });
                
                let messageContent = '';
                let visualizationHtml = '';
                let thinkingHtml = '';

                if (biResult.hasVisualization || biResult.biData) {
                    const viz = biResult.biData?.visualization;
                    const thinking = biResult.biData?.thinking;
                    console.log('[addMessage] Viz type:', viz?.type, 'Visualizable:', viz?.visualizable);
                    
                    // Render thinking chain if available
                    if (thinking && thinking.length > 0) {
                        thinkingHtml = renderThinkingChain(thinking);
                    }
                    
                    // Render the visualization
                    if (viz) {
                        visualizationHtml = renderVisualization(viz);
                    }
                    
                    // Always show the original text from the agent (biData.text has the full response)
                    messageContent = biResult.biData?.text || biResult.cleanText;
                } else {
                    messageContent = biResult.cleanText;
                }

                messageDiv.className = 'flex items-start gap-3';
                messageDiv.innerHTML = `
                    <div class="w-10 h-10 bg-iserv-green rounded-full flex items-center justify-center flex-shrink-0">
                        <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"/>
                        </svg>
                    </div>
                    <div class="flex-1" style="max-width: calc(100% - 52px);">
                        ${thinkingHtml}
                        ${messageContent ? `
                        <div class="bg-gray-100 rounded-2xl rounded-tl-sm px-5 py-3 inline-block max-w-full">
                            <div class="text-gray-800 leading-relaxed whitespace-pre-wrap markdown-content">${renderMarkdown(messageContent)}</div>
                        </div>
                        ` : ''}
                        ${visualizationHtml}
                        <p class="text-xs text-gray-400 mt-1 ml-1">${time}</p>
                    </div>
                `;
            }
            
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        /**
         * Escape HTML to prevent XSS
         */
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /**
         * Render basic markdown to HTML
         * Supports: **bold**, *italic*, lists, line breaks
         */
        function renderMarkdown(text) {
            if (!text) return '';
            
            // Split into lines to process lists properly
            const lines = text.split('\n');
            const processedLines = [];
            let inList = false;
            
            for (let i = 0; i < lines.length; i++) {
                let line = lines[i];
                
                // Escape HTML first
                line = escapeHtml(line);
                
                // Check if it's a list item
                const listMatch = line.match(/^(\s*)[-*]\s+(.+)$/);
                const numberedMatch = line.match(/^(\s*)(\d+)\.\s+(.+)$/);
                
                if (listMatch || numberedMatch) {
                    if (!inList) {
                        processedLines.push('<ul class="markdown-list">');
                        inList = true;
                    }
                    const content = listMatch ? listMatch[2] : numberedMatch[3];
                    // Process bold and italic in list items
                    const processedContent = processInlineMarkdown(content);
                    processedLines.push(`<li class="markdown-list-item">${processedContent}</li>`);
                } else {
                    if (inList) {
                        processedLines.push('</ul>');
                        inList = false;
                    }
                    // Process inline markdown (bold, italic)
                    line = processInlineMarkdown(line);
                    if (line.trim()) {
                        processedLines.push(`<span class="text-line">${line}</span>`);
                    }
                }
            }
            
            if (inList) {
                processedLines.push('</ul>');
            }
            
            // Join content - lists don't need <br>, text lines do
            let result = '';
            for (let i = 0; i < processedLines.length; i++) {
                const current = processedLines[i];
                const next = processedLines[i + 1];
                result += current;
                // Add <br> only between text lines, not around lists
                if (current.includes('text-line') && next && next.includes('text-line')) {
                    result += '<br>';
                }
            }
            return result;
        }

        /**
         * Process inline markdown (bold, italic)
         */
        function processInlineMarkdown(text) {
            // Convert **bold** to <strong>
            text = text.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
            
            // Convert *italic* to <em> (but not if it's part of **bold**)
            // Use negative lookbehind/lookahead to avoid conflicts
            text = text.replace(/(?<!\*)\*([^*\n]+?)\*(?!\*)/g, '<em>$1</em>');
            
            return text;
        }

        initializeSession();
    </script>
</body>
</html>
